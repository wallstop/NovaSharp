# Skill: Adding New VM Opcodes

**When to use**: Implementing new bytecode instructions in the NovaSharp VM.

______________________________________________________________________

## Overview

NovaSharp uses a bytecode VM with per-function bytecode and stack-based execution. Adding a new opcode requires changes in multiple locations.

______________________________________________________________________

## Steps to Add an Opcode

### 1. Update the `OpCode` enum

Location: `src/runtime/WallstopStudios.NovaSharp.Interpreter/Execution/VM/OpCode.cs`

```csharp
public enum OpCode
{
    // ... existing opcodes ...
    
    /// <summary>
    /// Description of what the new opcode does.
    /// Stack: [operand1, operand2] → [result]
    /// </summary>
    NewOpCode = NextAvailableValue,
}
```

**Requirements**:

- Explicit integer value
- XML doc comment describing stack effect
- Follow existing naming conventions

### 2. Implement in `Processor.Processing_Loop()`

Location: `src/runtime/WallstopStudios.NovaSharp.Interpreter/Execution/VM/Processor.cs`

Find the main processing loop and add a case:

```csharp
case OpCode.NewOpCode:
{
    // Pop operands from stack
    DynValue operand2 = m_ValueStack.Pop();
    DynValue operand1 = m_ValueStack.Pop();
    
    // Perform operation
    DynValue result = /* compute result */;
    
    // Push result
    m_ValueStack.Push(result);
    break;
}
```

### 3. Emit in AST node's `Compile()` method

Location: Relevant AST node in `src/runtime/WallstopStudios.NovaSharp.Interpreter/Tree/`

```csharp
public override void Compile(ByteCode bc, FunctionBuilder fb)
{
    // Compile operands (pushes to stack)
    m_Operand1.Compile(bc, fb);
    m_Operand2.Compile(bc, fb);
    
    // Emit the opcode
    bc.Emit_NewOpCode();
}
```

You may need to add an emit helper in `ByteCode.cs`:

```csharp
public void Emit_NewOpCode()
{
    Emit(OpCode.NewOpCode);
}
```

### 4. Test execution

Create TUnit tests:

```csharp
[Test]
[AllLuaVersions]
public async Task NewOpcodeWorksCorrectly(LuaCompatibilityVersion version)
{
    Script script = CreateScript(version);
    DynValue result = script.DoString("return <lua code that triggers opcode>");
    await Assert.That(result.Number).IsEqualTo(expectedValue).ConfigureAwait(false);
}
```

### 5. Test serialization (if applicable)

If the opcode appears in serialized bytecode, ensure it round-trips correctly:

```csharp
[Test]
[AllLuaVersions]
public async Task NewOpcodeSerializesCorrectly(LuaCompatibilityVersion version)
{
    Script script = CreateScript(version);
    DynValue func = script.LoadString("return <code>");
    
    // Serialize
    using MemoryStream ms = new();
    script.Dump(func, ms);
    
    // Deserialize and execute
    ms.Position = 0;
    DynValue loaded = script.LoadStream(ms);
    DynValue result = script.Call(loaded);
    
    await Assert.That(result.Number).IsEqualTo(expectedValue).ConfigureAwait(false);
}
```

______________________________________________________________________

## Key Files

| File                        | Purpose                   |
| --------------------------- | ------------------------- |
| `Execution/VM/OpCode.cs`    | Opcode enum definition    |
| `Execution/VM/Processor.cs` | Main execution loop       |
| `Execution/VM/ByteCode.cs`  | Bytecode emission helpers |
| `Tree/Expressions/*.cs`     | AST expression nodes      |
| `Tree/Statements/*.cs`      | AST statement nodes       |

______________________________________________________________________

## Architecture Context

```
Lua Source → Lexer → Parser → AST → Compiler → Bytecode → VM → Execution
                                        ↑              ↑
                                    Emit opcode    Execute opcode
```

- **Compiler**: AST nodes call `ByteCode.Emit_*()` methods
- **VM**: `Processor.Processing_Loop()` executes opcodes
- **Stack**: Operations pop operands and push results

______________________________________________________________________

## Debugging Tips

1. Add logging in `Processing_Loop()` to trace execution
1. Use `ByteCode.Dump()` to inspect generated bytecode
1. Compare generated bytecode with reference Lua using `luac -l`
