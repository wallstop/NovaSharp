# Modern Testing & Coverage Plan

## Repository Snapshot — 2025-12-01 (UTC)
- Build: `dotnet build src/NovaSharp.sln -c Release` (2025-12-01 01:34 UTC) finished with zero warnings while `<TreatWarningsAsErrors>true>` stays enforced across the solution.
- Tests: `scripts/coverage/coverage.ps1` now runs exclusively against the interpreter and remote-debugger TUnit hosts via Microsoft.Testing.Platform. The latest Release sanity run (2025-12-01 01:35 UTC) executed **2,728** interpreter/remote tests (`src/tests/NovaSharp.Interpreter.Tests.TUnit` + `src/tests/NovaSharp.RemoteDebugger.Tests.TUnit`) with zero failures. `FixtureCatalogGenerated.cs` now records **0** NUnit fixtures; the generator script remains so analyzers stay happy if any future NUnit project appears.
- Coverage: `docs/coverage/latest/Summary.md` now reflects the 2025-11-30 17:57 UTC artefacts from the post-TUnit coverage sweep (**86.5 % line / 86.5 % branch / 88.8 % method** overall). Interpreter coverage sits at **96.10 % line / 93.80 % branch / 97.52 % method**, so `COVERAGE_GATING_MODE` remains in monitor mode until branch coverage clears the ≥95 % bar.
  - NovaSharp.Interpreter: 96.13 % line / 93.83 % branch / 97.56 % method (still <95 % branch, so `COVERAGE_GATING_MODE` remains in monitor mode).
  - NovaSharp.Cli: 83.02 % line / 76.26 % branch.
  - NovaSharp.Hardwire: 55.72 % line / 46.58 % branch.
  - NovaSharp.RemoteDebugger: 76.73 % line / 66.25 % branch (headless debugger TUnit coverage is active again).
  - NovaSharp.VsCodeDebugger: 1.84 % line / 2.08 % branch (DAP automation still pending).
- Coverage collateral: rerun `./scripts/coverage/coverage.ps1` (Microsoft.Testing.Platform-aware) and refresh `docs/coverage/coverage-hotspots.md` whenever numbers move; last refresh completed 2025-11-30 17:57 UTC with the figures above.
- Audits: `documentation_audit.log`, `naming_audit.log`, and `spelling_audit.log` are green (0 missing XML docs, no naming/spelling findings). Re-run the trio whenever APIs or text-heavy docs change.
- Regions: `rg -n '#region'` only returns AGENTS.md/PLAN.md, so runtime/tooling/tests remain region-free.

## Baseline Controls (must stay green)
- Keep the documentation audit checked in. Re-run `python tools/DocumentationAudit/documentation_audit.py --write-log documentation_audit.log` whenever public/internal APIs change.
- `tools/NamingAudit` and `tools/SpellingAudit` are wired into CI; refresh `naming_audit.log` and `spelling_audit.log` locally before pushing code that touches identifiers or docs.
- Run the lint guards (`python scripts/lint/check-platform-testhooks.py` / `scripts/ci/check-platform-testhooks.sh` and `python scripts/lint/check-console-capture-semaphore.py` / `scripts/ci/check-console-capture-semaphore.sh`) before pushing; the CI lint job invokes the same scripts and will fail if detector/semaphore scopes are bypassed.
- Namespace/script hub governance already gates CI. Any new helper must live under `scripts/<area>/` with a README update plus PR-template acknowledgement.
- Re-run `rg -n '#region'` whenever generators or imports are added; update offending generators to strip regions automatically.
- Keep `docs/Testing.md`, `docs/Modernization.md`, and `scripts/README.md` aligned with the helpers in `scripts/` so contributors have a single source of truth.

## Active Initiatives

### CSharpier formatting backlog
- Current status: the entire repo (runtime/tooling/tests) has been reflowed with `dotnet csharpier`, and CI’s lint job now runs `dotnet csharpier check .` via `scripts/ci/check-csharpier.sh`. Treat any lingering `dotnet format` complaints as configuration bugs and update `.editorconfig`/workflow settings so they no longer contradict CSharpier output. **Next steps:** align the remaining formatter configuration (dotnet-format, IDE analyzers) with CSharpier and document the policy in `docs/Testing.md`/contributor guides once the tooling is in sync.

### Highest priority - Test cleanup helpers & using-pattern enforcement
- Problem: interpreter/tooling/CLI fixtures still rely on ad-hoc `try`/`finally` blocks (platform overrides, Unity harness toggles, temp directories, console capture) which leads to missed tear-down paths when new assertions short-circuit the test. We need a repo-wide sweep to replace the manual cleanup logic with `IDisposable` helpers that are consumed via `using` statements (or the C# 8 `using var` pattern) so resource lifetimes are explicit and analyzer-friendly.
- Plan of record:
  1. Inventory every `try`/`finally` pair under `src/tests` (NUnit + TUnit) and categorize the cleanup semantics (temp files, platform overrides, Unity harness toggles, user-data registrations, `Script.GlobalOptions` resets, environment variables, IO streams, etc.).
  2. For each category, design or extend a reusable `IDisposable` helper (e.g., `PlatformOverrideScope`, `TempDirectoryScope`, `UserDataIsolationScope`, `GlobalOptionsScope`, `ConsoleCaptureScope`). Prefer colocating these in `TestInfrastructure/Scopes` so both NUnit and TUnit projects can share them.
  3. Codemod the identified tests to depend on the new helpers via `using` statements rather than manual `try`/`finally` blocks. Favor data-driven helpers (e.g., `using var scope = PlatformOverrideScope.UnityDesktop();`) so the intent is obvious in each test.
  4. Add an analyzer or Roslyn-based lint (even a temporary `rg`/CI script) that flags new `try`/`finally` usage in tests when the `finally` block simply tears down disposable state, keeping the suite aligned with the helper abstractions long term.
  5. Update `docs/Testing.md` + AGENTS.md so contributors know to reach for the helper scopes before writing manual cleanup logic, and highlight this initiative in PR templates until the sweep is finished.
- Current status: CLI/harness suites now run console capture through `ConsoleCaptureCoordinator.RunAsync`; interpreter/remote tests share `TempDirectoryScope`, `PlatformDetectorOverrideScope`, and `PlatformDetectorScope`; Unity loader tests use the new reflection scope; and CI lint guards (`check-platform-testhooks.sh`, `check-console-capture-semaphore.sh`) enforce detector/semaphore usage. Remote-debugger harnesses/utilities still contain bespoke cleanup helpers, and the CLI projects continue to rely on CA2007 suppressions because `ConfigureAwait(false)` hasn't been applied everywhere.
- Recent progress: Scope helpers now cover every test suite (enforced by `check-test-finally.py`), and the CA2007/`ConfigureAwait(false)` sweep is steadily reducing the remaining suppressions across CLI, descriptor, and IO tests.
- Completed CA2007 conversions to date: RemoteDebugger utilities, all CLI command/repl suites, and the bulk of interpreter modules (Basic, Math, String, Table, Coroutine, Debug, Json, OsTime, Load, LuaBase, Bit32, StandardIo). Each now awaits assertions via ConfigureAwait(false) with green dotnet test --project src/tests/NovaSharp.Interpreter.Tests.TUnit/NovaSharp.Interpreter.Tests.TUnit.csproj -c Release runs.
- 2025-12-01 23:03 UTC: Finished the descriptor sweep (`ArrayMemberDescriptorGeneratorTUnitTests`, `HardwireCodeGenerationContextTUnitTests`, `HardwireParameterDescriptorTUnitTests`, `HardwiredDescriptorTUnitTests`, `HardwiredMemberDescriptorTUnitTests`, `HardwiredMethodMemberDescriptorTUnitTests`, `HardwiredUserDataDescriptorTUnitTests`, `StandardEnumUserDataDescriptorTUnitTests`). Every awaited assertion/helper now calls `.ConfigureAwait(false)`, the helper methods follow suit, and the per-file CA2007 pragmas were deleted (`rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Descriptors` returns zero matches). Skipped a dotnet test run here; the next contributor should spot-check the descriptor suite alongside their edits.
- 2025-12-01 23:09 UTC: Converted the `UserDataPropertiesTUnitTests`, `UserDataFieldsTUnitTests`, and `UserDataIndexerTUnitTests` fixtures to await every assertion/helpers with `.ConfigureAwait(false)`, cleaned up the nested helper lambdas, and removed their CA2007 pragmas. `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/EndToEnd | rg UserData` now only lists `UserDataMethods`, `UserDataEvents`, `UserDataOverloads`, `UserDataNestedTypes`, `UserDataMeta`, and `UserDataEnums`. No interpreter TUnit run yet; please spot-check the EndToEnd suite before flipping more pragmas.
- 2025-12-01 23:18 UTC: Finished the remaining EndToEnd user-data fixtures (`UserDataMethodsTUnitTests`, `UserDataEventsTUnitTests`, `UserDataOverloadsTUnitTests`, `UserDataNestedTypesTUnitTests`, `UserDataMetaTUnitTests`, `UserDataEnumsTUnitTests`). Every `await` now ends with `.ConfigureAwait(false)`, helper lambdas were updated accordingly, and all CA2007 pragmas under `src/tests/NovaSharp.Interpreter.Tests.TUnit/EndToEnd/UserData*` were removed (`rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/EndToEnd | rg UserData` returns zero matches). Still skipped `dotnet test`—please spot-check the interpreter TUnit suite when convenient.
- 2025-12-01 23:24 UTC: Started sweeping the Units fixtures by cleaning the debugger-focused suites (`DebuggerActionTUnitTests`, `DebuggerBreakpointTUnitTests`, `DebuggerRefreshTUnitTests`, `DebuggerResumeHelpersTUnitTests`, `DebugServiceTUnitTests`, `Units/Debugging/WatchItemTUnitTests`, `Units/Debugging/SourceRefTUnitTests`). All of their awaited assertions/helpers now call `.ConfigureAwait(false)`, the helper methods stay readable, and their CA2007 pragmas are gone. Remaining Units pragmas now live in the parser/VM/data-structure suites listed by `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units`.
- 2025-12-01 23:32 UTC: Continued the Units sweep by converting `BinaryOperatorExpressionTUnitTests` to `.ConfigureAwait(false)` and deleting its pragma. The helper lambdas and bulk test cases now await consistently, clearing one of the largest parser/VM fixtures.
- 2025-12-01 23:40 UTC: Cleaned the next Units batch—`BinaryEncodingTUnitTests`, `BinaryMetamethodTUnitTests`, `AssignmentStatementTUnitTests`, `ClosureContextTUnitTests`, and `AnonWrapperTUnitTests`. Each now awaits assertions/helpers with `.ConfigureAwait(false)` and no longer uses CA2007 pragmas. Remaining Units suppressions are concentrated in the parser/data-structure suites listed by `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units`.
- 2025-12-01 23:48 UTC: Converted another Units slice (`ClrToScriptConversionsTUnitTests`, `CompatibilityDiagnosticsTUnitTests`, `CoroutineLifecycleTUnitTests`, `BuildTimeScopeFrameTUnitTests`, `CloseAttributeTUnitTests`) to `.ConfigureAwait(false)` and removed their CA2007 pragmas. Parser/data-structure fixtures still listed by `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units` remain on deck.
- 2025-12-01 23:55 UTC: Continued the parser/data-structure sweep by converting `DynamicExprAndAdjustmentExpressionTUnitTests`, `DataStructs/SliceDataStructsTUnitTests`, `DotNetCorePlatformAccessorTUnitTests`, `CustomConverterRegistryTUnitTests`, and `DescriptorHelpersTUnitTests`. All awaited assertions/helpers now call `.ConfigureAwait(false)` and these files are CA2007-free. Remaining suppressions are down to the long tail of parser/data-structure fixtures enumerated by `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units`.
- 2025-12-01 23:59 UTC: Finished the next parser/data-structure batch (`ClosureTUnitTests`, `DynamicExpressionTUnitTests`, `DynamicModuleTUnitTests`, `DynValueTUnitTests`, `EventFacadeTUnitTests`, `EnumerableWrapperTUnitTests`, `FastStackDynamicTUnitTests`, `ErrorHandlingModuleTUnitTests`, `ExprListExpressionTUnitTests`). Every awaited assertion/helper now uses `.ConfigureAwait(false)` and the per-file CA2007 pragmas are gone. Remaining suppressions are limited to the suites still surfaced by `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units`.
- 2025-12-01 24:05 UTC: Continued the sweep with `FastStackTUnitTests`, ensuring every awaited assertion/helper calls `.ConfigureAwait(false)` and removing its CA2007 pragma. Remaining Units suppressions are listed by `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units`.
- 2025-12-02 00:31 UTC: Converted the next Units slice (`FrameworkCurrentTUnitTests`, `HardwireGeneratorRegistryTUnitTests`, `HardwireGeneratorTUnitTests`, `HardwiredDescriptorsTUnitTests`, `IndexExpressionTUnitTests`, `InstructionFieldUsageExtensionsTUnitTests`) to add `.ConfigureAwait(false)` to every awaited assertion/helper and removed their CA2007 pragmas. `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units | rg -E \"(FrameworkCurrent|Hardwire|HardwiredDescriptors|IndexExpression|InstructionFieldUsage)\"` now returns zero matches. Skipped `dotnet test`—follow-up contributors should spot-check the Units suites when batching additional files.
- 2025-12-02 00:34 UTC: Swept the next batch (`InfrastructureTUnitTests`, `InternalErrorExceptionTUnitTests`, `InterpreterExceptionTUnitTests`, `InteropRegistrationPolicyTUnitTests`, `JsonNullTUnitTests`, `InteropTUnitTests`). Every awaited assertion now ends with `.ConfigureAwait(false)`, the helper/control-flow awaits were updated accordingly, and each file’s CA2007 pragma was deleted. Verified the removals with `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units | rg -E \"(Infrastructure|InternalErrorException|InterpreterException|InteropRegistrationPolicy|JsonNull|InteropTUnit)\"` (no matches). Tests still pending—please include a TUnit pass when you convert additional files.
- 2025-12-02 00:36 UTC: Converted another Units slice (`LabelStatementTUnitTests`, `LinkedListIndexTUnitTests`, `LexerUtilsTUnitTests`, `LoopBoundaryTUnitTests`, `LinqHelpersTUnitTests`, `LiteralExpressionTUnitTests`). All awaits now chain `.ConfigureAwait(false)` (including helper methods like `AssertLiteral`), and the CA2007 pragmas were removed from each file. Verified via `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units | findstr \"LabelStatement LinkedListIndex LexerUtils LoopBoundary LinqHelpers LiteralExpression\"` (no matches). Still skipping `dotnet test`; please run the interpreter TUnit project once more files are swept.
- 2025-12-02 00:39 UTC: Swept the modding/metatable batch (`MetatableTUnitTests`, `ModManifestTUnitTests`, `ModManifestCompatibilityTUnitTests`, `LuaTypeExtensionsTUnitTests`, `MultiDictionaryTUnitTests`, `ModuleArgumentValidationTUnitTests`). Every awaited assertion/helper now calls `.ConfigureAwait(false)`, helper methods were updated (e.g., `AssertLiteral`, module validation helpers), and the CA2007 pragmas were deleted. Verified via `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units | findstr \"Metatable ModManifestCompatibility ModManifest LuaTypeExtensions MultiDictionary ModuleArgumentValidation\"` (no matches). Tests still pending; please batch a `dotnet test src/tests/NovaSharp.Interpreter.Tests.TUnit/NovaSharp.Interpreter.Tests.TUnit.csproj -c Release` run once the remaining Units files are converted.
- 2025-12-02 00:45 UTC: Converted the next Units slice (`ValueTypeDefaultCtorMemberDescriptorTUnitTests`, `PerformanceStopwatchTUnitTests`, `PerformanceCountersTUnitTests`, `PerformanceStatisticsTUnitTests`, `UndisposableStreamTUnitTests`, `NodeBaseTUnitTests`, `NumericConversionsTUnitTests`, `NovaSharpHideMemberAttributeTUnitTests`, `ObjectValueConverterTUnitTests`, `ParameterDescriptorTUnitTests`, `PathSpanExtensionsTUnitTests`). All awaits now end with `.ConfigureAwait(false)` (covering helper methods such as the `NodeBase` token checks, `ParameterDescriptor` wiring helpers, diagnostics stopwatches, and the path-span copy routines), CA2007 pragmas were removed (leaving only the CA1849 suppression in `UndisposableStream`), and verification via `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units | findstr \"ValueTypeDefaultCtor PerformanceStopwatch PerformanceCounters PerformanceStatistics UndisposableStream NodeBase NumericConversions NovaSharpHide ObjectValueConverter ParameterDescriptor PathSpan\"` returns no matches. Tests still deferred until the sweep wraps.
- 2025-12-02 00:48 UTC: Converted the next Units slice (`StandardGenericsUserDataDescriptorTUnitTests`, `StringRangeTUnitTests`, `StringSpanExtensionsTUnitTests`, `StringConversionsTUnitTests`, `SourceRefTUnitTests`, `SourceCodeTUnitTests`). Every awaited assertion/helper now chains `.ConfigureAwait(false)` (including data-driven helpers such as the descriptor generation paths, span utilities, and `SourceRef` formatting helpers), and their CA2007 pragmas were deleted. Verified via `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units | findstr \"StandardGenerics StringRange StringSpan StringConversions SourceRef SourceCode\"` (no matches). Still deferring `dotnet test` until the remaining Units fixtures are cleaned.
- 2025-12-02 00:55 UTC: Cleared another batch (`UserDataTUnitTests`, `StandardPlatformAccessorTUnitTests`, `UserDataIsolationTUnitTests`, `UnaryOperatorExpressionTUnitTests`, `SliceTUnitTests`, `TokenTUnitTests`, `TablePairTUnitTests`, `SerializationExtensionsTUnitTests`, `TableTUnitTests`, `TableConversionsTUnitTests`, `SyntaxErrorExceptionTUnitTests`, `TailCallTUnitTests`). All awaits (including the large UserData infrastructure suite) now end with `.ConfigureAwait(false)`, helper methods were updated accordingly, and every CA2007 pragma across these files was removed. Verified with `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units | findstr \"UserData StandardPlatform UnaryOperator Slice Token TablePair SerializationExtensions TableT TableConversions SyntaxError TailCall\"` (no matches). Tests still pending until the full sweep completes.
- 2025-12-02 00:58 UTC: Began converting the EndToEnd suites, covering (`CollectionsBaseInterfaceRegisteredTUnitTests`, `BinaryDumpTUnitTests`, `ClosureTUnitTests`, `CollectionsBaseGenRegisteredTUnitTests`, `EndToEndDynValueAssert.cs`, `DynamicTUnitTests`). Every awaited assertion/helper (including the shared `RunScriptAsync` helpers) now chains `.ConfigureAwait(false)`, the helper delegates do the same, and each file’s CA2007 pragma was removed (CA1814/other pragmas left intact where required). Verified with `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/EndToEnd | findstr \"CollectionsBaseInterface BinaryDump Closure CollectionsBaseGen EndToEndDynValue Dynamic\"` (no matches). Next pass: continue through the remaining EndToEnd fixtures plus the CLI test to finish the repo-wide CA2007 sweep before running `dotnet test`.
- 2025-12-02 01:02 UTC: Continued the EndToEnd sweep by updating (`ConfigPropertyAssignerTUnitTests`, `CollectionsRegisteredTUnitTests`, `CoroutineTUnitTests`, `ErrorHandlingTUnitTests`, `LuaTestSuiteExtractTUnitTests`, `VarargsTupleTUnitTests`). All awaits (including the shared helper delegates) now call `.ConfigureAwait(false)` and their CA2007 pragmas were removed. Verified with `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/EndToEnd | findstr \"ConfigPropertyAssigner CollectionsRegistered Coroutine ErrorHandling LuaTestSuite VarargsTuple\"` (no matches). **Next up:** finish the remaining EndToEnd fixtures listed by `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/EndToEnd` (Goto, JsonSerialization, Metatable, ProxyObjects, RealWorldScript, StructAssignmentTechnique, TableTUnitTests, etc.) plus the CLI test, then run `dotnet test src/tests/NovaSharp.Interpreter.Tests.TUnit/NovaSharp.Interpreter.Tests.TUnit.csproj -c Release` so CA2007 can be re-enabled repo-wide.
- 2025-12-02 00:52 UTC: Converted the diagnostics/platform slice (`ReflectionSpecialNamesTUnitTests`, `ProcessorBinaryDumpTUnitTests`, `RefIdObjectTUnitTests`, `PropertyTableAssignerTUnitTests`, `SystemHighResolutionClockTUnitTests`). All awaits (including helper calls like the property-table assigner wiring, stopwatch timing assertions, and ReflectionSpecialName operator loops) now use `.ConfigureAwait(false)`, and the CA2007 pragmas were removed. Verified via `rg -n '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units | findstr \"ReflectionSpecial ProcessorBinary RefId PropertyTableAssigner SystemHigh\"` (no matches). Tests still pending until the sweep wraps.
- Next steps: (1) keep slicing through the remaining parser/data-structure Units files reported by `rg -l '#pragma warning disable CA2007' src/tests/NovaSharp.Interpreter.Tests.TUnit/Units`; (2) once the list is empty, run `dotnet test src/tests/NovaSharp.Interpreter.Tests.TUnit/NovaSharp.Interpreter.Tests.TUnit.csproj -c Release` and re-enable CA2007 repo-wide so new code can’t regress.
- Remaining CA2007 suppressions now live in the remaining Units suites (parser/VM/data-structures/etc.—see the latest `rg -l '#pragma warning disable CA2007'` snapshot). **Next pass**: continue sweeping those fixtures to add `.ConfigureAwait(false)` and drop their pragmas so we can re-enable CA2007 repo-wide.
- Ease-of-use backlog (still active):
  1. DynValue.ToObject<T>(...) convenience helpers.
  2. UserDataRegistrationScope.Track overloads/Register<T> helpers for multi-type registration.
  4. Generalized static-field override scopes for CLI/Debugger hooks.
  5. Shared PlatformDetectorScope for isolation attributes/tests.
- Current focus / next steps:
  1. Finish the ConfigureAwait(false) sweep across the remaining CA2007-suppressed suites (CLI integration, descriptor generators, RemoteDebugger utilities) and re-enable the analyzer repo-wide.
  2. Monitor the new `check-test-finally.py` guard in CI and extend it (or a Roslyn analyzer) if additional cleanup patterns emerge.
  3. Pivot to the remote-debugger automation/cleanup initiative once CA2007 debt is cleared.
### High priority — Codebase organization & namespace hygiene
- Current state: runtime/tooling/test projects largely mirror the historical MoonSharp layout, leaving most interpreter tests under monolithic buckets such as `Units/`, `TestMore/`, or `TUnit/VM/` with little discoverability. Production code follows the same pattern—`NovaSharp.Interpreter` is a single assembly containing interpreter, modules, platforms, IO helpers, and tooling adapters.
- Problem: Contributors struggle to locate feature-specific code/tests, and the wide namespaces make it hard to reason about ownership or layering (e.g., Lua VM vs. tooling vs. debugger). PLAN.md now tracks the reorganization as a high-priority initiative so we treat it as a first-class modernization step alongside TUnit.
- Objectives:
  1. Propose a refined solution layout that splits runtime/tooling/test assets into feature-scoped projects (e.g., `NovaSharp.Interpreter.Core`, `NovaSharp.Interpreter.IO`, `NovaSharp.Tooling.Cli`, `NovaSharp.Tests.Interpreter.Runtime`, `NovaSharp.Tests.Interpreter.Modules`, etc.) while keeping build scripts and packaging intact.
  2. Restructure the interpreter test tree by domain rather than framework (e.g., `Runtime/VM`, `Runtime/Modules`, `Tooling/Cli`, `Debugger/Remote`, `Integration/EndToEnd`). Update namespaces to match the new folder structure and keep fixture catalog generation aligned.
  3. Document the new layout in PLAN.md + `docs/Testing.md`, and add guardrails (analyzers or CI checks) so new code/tests land in the correct folders with consistent namespaces.
  4. Ensure the reorganization is incremental but tracked: migrate one subsystem at a time, update project references, and verify coverage after each move so we do not destabilize the main branch.

### 1. Analyzer and warning debt
- Current status (2025-12-09): dotnet build src/NovaSharp.sln -c Release -nologo remains clean with <TreatWarningsAsErrors>true> enforced across the solution. **Next steps:** document any new suppressions in PLAN.md/docs/Testing.md, keep the PR template’s analyzer checklist up to date, and treat fresh CA hits as stop-ship items.
- Active follow-up: audit the remaining targeted suppressions (e.g., CA1051 field fixtures, IDE1006 Lua port intentional cases, module-level CA1515) and convert any that are no longer needed into real code fixes so the analyzer baseline remains suppression-light.
- CA1051 follow-up: the previously flagged test fixtures (`TestRunner` counters plus descriptor/userdata helpers) are clean, but keep auditing new test infrastructure so any future public-field regressions are either converted to properties or annotated with tightly scoped suppressions.
- CA1515 plan: fixture catalog automation (MSBuild, pre-commit, CI) now ensures every `[TestFixture]` has a `typeof(...)` reference in `FixtureCatalogGenerated.cs`. Next steps are (a) convert non-reflection fixtures/helpers to `internal` where possible and (b) scope the remaining CA1515 suppressions to the handful of helper types that must stay public for NUnit/BenchmarkDotNet.
- BenchmarkDotNet benchmark classes (`RuntimeBenchmarks`, `ScriptLoadingBenchmarks`, `LuaPerformanceBenchmarks`) must remain `public` and unsealed for discovery; keep the targeted CA1515 suppressions plus the AGENTS.md guidance so new benchmarks follow the same pattern.
- Policy reminder: AGENTS.md forbids nullable reference-type syntax (no `#nullable`, `string?`, `?.` targeting reference members, or `null!`). Keep running `artifacts/NrtScanner` (or a simple `rg`) before opening analyzer-heavy PRs so the ban stays enforced and CA1805 continues to pass without suppressions.

### 2. Coverage and test depth
- Refresh artefacts: rerun ./scripts/coverage/coverage.ps1 (Release, gate = enforce) so docs/coverage/latest/* and docs/coverage/coverage-hotspots.md describe the latest test suite.
- 2025-11-30 09:28 UTC: Reran `./scripts/coverage/coverage.ps1` (Release suites: **2,136** interpreter TUnit + **40** remote-debugger TUnit + **881** NUnit) after wiring up the Hardwire/Module conversions. The run finished with **0** failures, refreshed `docs/coverage/latest/*` + `docs/coverage/coverage-hotspots.md`, and reports NovaSharp.Interpreter at **96.13 % line / 93.83 % branch / 97.56 % method**; `COVERAGE_GATING_MODE` stays in monitor mode until branch coverage clears the ≥95 % bar.
- Remote-debugger coverage is back to **76.73 % line / 66.25 % branch**, but NovaSharp.VsCodeDebugger still sits at **1.84 % line / 2.08 % branch**, so the DAP smoke tests remain a top priority.
- Interpreter: add debugger/coroutine regression tests that drive pause-during-refresh, queued actions that drain after a pause, forced resume, and message decoration paths so branch coverage climbs from ~93 % to ≥95 %.
- Tooling: extend NovaSharp.Cli tests beyond current command-unit coverage (record REPL transcripts and golden outputs) and build Hardwire generator tests that validate descriptor generation/error handling, targeting ≥80 % line coverage for each project.
- Debuggers: add headless VS Code + Remote Debugger smoke tests (attach/resume/breakpoint/watch evaluation) to push NovaSharp.VsCodeDebugger line coverage past 50 % and NovaSharp.RemoteDebugger branch coverage above 85 %.
- Replace skipped IO/OS TAP suites with NUnit fixtures so Release runs exercise those semantics without Lua harnesses.
- Observability: enhance the GitHub coverage job to compare the new Summary.json against the last successful run and fail on ≥3 percentage point regressions; archive history under rtifacts/coverage/history.
- Remaining interpreter branch debt (updated 2025-11-26 21:45 UTC): Coroutine (~83.3 %), UnityAssetsScriptLoader (~86.8 %), PlatformAutoDetector (~87.5 %), Script (~83.8 %), UnaryOperatorExpression (~85 %), and any lingering Script/repl/helpers not yet converted to guard-tested code paths. Prioritize these guard paths so interpreter branch coverage can cross ≥95 % and we can re-enable gating.
- Next steps: Close out the remaining hotspots (Coroutine, UnityAssetsScriptLoader, PlatformAutoDetector, Script, UnaryOperatorExpression, and the outstanding Script/REPL helpers) by adding guard-path unit tests so interpreter branch coverage can cross the ≥95 % enforcement bar.

### 3. Debugger and tooling automation
- Build a DAP test harness that drives NovaSharp.VsCodeDebugger end-to-end (launch, attach, breakpoints, watches) without requiring VS Code, and feed its transcripts into NUnit.
- Add CLI integration tests that execute scripted sessions (stdin/stdout golden files) covering success/failure paths for `run`, `register`, `debug`, `compile`, `hardwire`, and `help` commands.
- Stand up remote-debugger smoke tests that exercise HTTP attach, TCP streaming, queue draining, and error signaling; add golden payload assertions so regressions show up in diffs.
- Expand CI beyond Linux so debugger + CLI automation also run on Windows and macOS, matching the platforms we claim to support.

### 4. Runtime safety, sandboxing, and determinism
- Design Lua sandbox profiles that toggle risky primitives (file IO, environment variables, OS commands, reflection hooks) and expose host-driven policies via `ScriptOptions`; document the behaviour in `docs/LuaCompatibility.md`.
- Add configurable ceilings for time, memory, recursion depth, coroutine counts, and table growth along with watchdog callbacks so runaway mods cannot stall hosts.
- Introduce a deterministic execution mode (stable PRNG seeding, invariant formatting, deterministic iteration where Lua allows) for lockstep multiplayer/replays.
- Provide per-mod isolation containers plus load/reload/unload hooks so mods do not leak state across sessions.

### 5. Packaging, performance, and runtime ergonomics
- Unity onboarding: automate UPM/embedded packaging, refresh the sample scenes, and capture IL2CPP/AOT caveats in `docs/UnityIntegration.md`; wire the packaging script into CI.
- Packaging pipeline: publish redistributable runtime bundles/NuGet packages with versioning/signatures and document the workflow in release notes.
- Enum allocation audit: port the allocation-free flag helpers/name maps to remove `Enum.HasFlags`/`ToString()` allocations on hot paths; add benchmarks and NUnit coverage.
- Custom collections: audit `LinkedListIndex`, `FastStack`, `MultiDictionary`, etc. for BCL parity, replace `ContainsKey`+indexer patterns with `TryGetValue`, and document preferred usage.
- Performance regression harness: run BenchmarkDotNet (runtime + comparison suites) in CI/nightly, capture allocation deltas, and require `docs/Performance.md` updates when numbers move.
- Investigate high-performance string/IO libraries (e.g., ZString) and prototype them in parser/IO hotspots without harming readability or Unity compatibility.
- String operations audit: inventory the runtime/tooling string formatting, concatenation, and builder-heavy paths, evaluate whether ZString or compiler-generated interpolation can replace ad-hoc `StringBuilder` usage, and document any trade-offs (Unity/IL2CPP safety, culture invariance) before landing changes.
- Interpreter hot-path optimization: profile the Lua VM (instruction loop, stack ops, call/return pipelines) to identify heap allocations and branch mispredictions, then prototype zero-allocation strategies (array/object pools, bit-packed instruction metadata, custom data structures, ZLINQ/ZString integration) and document measured wins before rolling them out broadly.
- I/O throughput audit: benchmark every runtime/tooling I/O surface (script loaders, REPL streams, debugger transports, file/tcp helpers), minimize allocations via pooling/buffering, and consider high-performance libraries (e.g., pipelines, Span-based readers) while keeping Unity/IL2CPP compatibility intact.
- Whole-runtime optimization pass: schedule iterative sweeps (excluding test code) that profile each subsystem, track allocations/instructions, and apply aggressive optimizations (custom data structures, pooling, bit packing, low-level intrinsics) where they deliver measurable wins without breaking API/back-compat.

### 6. Tooling, docs, and contributor experience
- Roslyn code generation milestone: design and prototype source generators/analyzers for NovaSharp descriptors/mod code, then document how to consume them.
- Documentation & samples: adopt DocFX (or similar), publish compatibility matrices/tutorials, refresh Unity/modding guides, and automate doc generation in CI.
- Compatibility corpus: expand CI to run Lua TAP suites, community mod packs, and script corpora across Windows, macOS, Linux, and Unity editor builds; track the matrix in `docs/Testing.md`.
- Style/quality automation: extend lint to reject runtime changes that lack matching tests (unless `[NoCoverageJustification]` is present), enforce `_camelCase` fields, and ensure new scripts/docs update the relevant indexes.
- 2025-11-26 23:59 UTC: Added contributor-facing ignore lists (`.claudeignore`, `.codexignore`) so both assistant profiles skip generated artefacts (bin/obj, coverage HTML, logs, IDE folders). **Next steps:** document the policy in `AGENTS.md` and keep the ignore lists updated when new artefact directories are introduced.

### 7. Outstanding investigations
- Confirm `pcall`/`xpcall` semantics when CLR callbacks yield; add regression tests or update runtime behaviour to match Lua 5.4 if needed.
- Decide whether `SymbolRefAttributes` should be renamed to satisfy CA1711 or if a documented suppression is acceptable; capture the outcome in this plan and analyzer settings.

### 8. Concurrency and synchronization audit
- Inventory every `lock`, `Monitor`, and ad-hoc concurrency helper across runtime, tooling, and debugger code. Document each critical section’s purpose, contention risk, and whether a `ReaderWriterLockSlim`, `SemaphoreSlim`, or lock-free primitive would improve scalability without hurting determinism.
- Identify shared collections that still use `List<T>`/`Dictionary<T>` under concurrent access (e.g., debugger server lists, HTTP caches, tooling registries). Where appropriate, switch to `ConcurrentDictionary<T>`/`ImmutableArray<T>` or add guarding APIs instead of external locks.
- Validate that dispose paths, async callbacks, and network events cannot deadlock (double-lock patterns, nested locks across types). Capture any required lock-ordering guidance in `docs/Modernization.md`.
- Benchmark contention-sensitive paths (RemoteDebugger queues, interpreter hook dispatch, CLI registries) before swapping primitives; keep measurements in `docs/Performance.md` so future changes have baselines.
- Produce a checked-in concurrency inventory (e.g., `docs/modernization/concurrency-inventory.md`) that lists every `lock`/`Monitor`/`SemaphoreSlim` usage, captures contention risk, and calls out candidates for `ReaderWriterLockSlim`/lock-free swaps so future reviewers can reason about synchronization at a glance.

## Lua specification parity
- Keep the Lua 5.4 parity matrix in `docs/LuaCompatibility.md` up to date; cite manual sections for every behaviour we touch.
- Extend the compatibility-mode surface so hosts can opt into Lua 5.1, 5.2, 5.3, or 5.4 semantics (chunk loading rules, standard library variants, coroutine differences) via `ScriptOptions`/`LuaCompatibilityProfile`, and back each mode with targeted NUnit + spec-harness coverage plus docs describing supported toggles.
- Extend the spec harness beyond the existing string suite (math, table, utf8, coroutine, debug, IO) and store fixtures beside the NUnit TAP corpus.
- Integrate the spec harness into CI so spec regressions fail builds; document the workflow in `docs/testing/spec-coverage.md`.
- Golden rule: when a regression test fails, assume production is wrong until the Lua 5.4 manual proves otherwise; prefer fixing runtime behaviour over weakening tests.

## Long-horizon ideas
- Property and fuzz testing for the lexer, parser, and VM instruction boundaries.
- Golden-file assertions for debugger protocol payloads and CLI output.
- Native AOT/trimming validation once the runtime stack is fully nullable-clean.
- Automated allocation regression harnesses using BenchmarkDotNet diagnosers or `dotnet-trace`.

Keep this plan aligned with `docs/Testing.md` and `docs/Modernization.md`, and update it whenever coverage artefacts, warning counts, or milestone statuses change.


