<#
.SYNOPSIS
    Generates FixtureCatalogGenerated.cs listing all NUnit [TestFixture] types so analyzers
    observe the fixtures even when they become internal.

.DESCRIPTION
    Scans the NovaSharp.Interpreter.Tests project for `[TestFixture]` declarations and emits a
    generated file that references every discovered type via `typeof(...)`. This keeps CA1812 and
    CA1515 satisfied once fixtures are made internal because the compiler now sees explicit usage.

.USAGE
    pwsh ./scripts/tests/update-fixture-catalog.ps1
#>

param(
    [string]$TestsRoot = "src/tests/NovaSharp.Interpreter.Tests",
    [string]$OutputPath = "src/tests/NovaSharp.Interpreter.Tests/FixtureCatalogGenerated.cs"
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Get-FixtureTypeNames {
    param([string]$Root)

    $fixtures = [System.Collections.Generic.List[string]]::new()

    Get-ChildItem -Path $Root -Filter *.cs -Recurse | ForEach-Object {
        $namespace = $null
        $pendingFixture = $false

        foreach ($line in Get-Content -LiteralPath $_.FullName) {
            if ($line -match '^\s*namespace\s+([A-Za-z0-9_.]+)') {
                $namespace = $matches[1]
                continue
            }

            if ($line -match '\[TestFixture') {
                $pendingFixture = $true
                continue
            }

            if ($pendingFixture) {
                if ($line -match '^\s*(public|internal)\s+(?:sealed\s+|static\s+|abstract\s+)?class\s+([A-Za-z0-9_`]+)') {
                    if (-not $namespace) {
                        throw "Missing namespace declaration in $($_.FullName)"
                    }

                    $fixtures.Add("global::$namespace.$($matches[2])")
                    $pendingFixture = $false
                    continue
                }

                if ($line.Trim().Length -eq 0 -or $line.TrimStart().StartsWith("[", [System.StringComparison]::Ordinal)) {
                    continue
                }

                $pendingFixture = $false
            }
        }
    }

    return @($fixtures | Sort-Object -Unique)
}

$fixtureTypes = @(Get-FixtureTypeNames -Root $TestsRoot)

$header = @"
// <auto-generated />
// Generated by scripts/tests/update-fixture-catalog.ps1
namespace NovaSharp.Interpreter.Tests
{
    using System;
    using System.Diagnostics.CodeAnalysis;

    [ExcludeFromCodeCoverage]
    internal static class FixtureCatalog
    {
        private static readonly Type[] ReferencedFixtures = new Type[]
        {
"@

$footer = @"
        };

        static FixtureCatalog()
        {
            _ = ReferencedFixtures.Length;
        }
    }
}
"@

if ($fixtureTypes.Count -eq 0) {
    $bodyBlock = "            // No NUnit fixtures remain."
}
else {
    $body = $fixtureTypes | ForEach-Object { "            typeof($_)," }
    $bodyBlock = $body -join [Environment]::NewLine
}

$footerContent = $footer.TrimStart([char[]]"`r`n")
$content = @($header.TrimEnd(), $bodyBlock, $footerContent) -join [Environment]::NewLine

Set-Content -LiteralPath $OutputPath -Value $content -Encoding UTF8
Write-Host "Generated $OutputPath with $($fixtureTypes.Count) fixtures."

