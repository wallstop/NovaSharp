namespace WallstopStudios.NovaSharp.Hardwire
{
    using System;
    using System.CodeDom;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Reflection;
    using Languages;
    using WallstopStudios.NovaSharp.Interpreter;
    using WallstopStudios.NovaSharp.Interpreter.DataTypes;
    using WallstopStudios.NovaSharp.Interpreter.Infrastructure;

    /// <summary>
    /// The context under which code is generated.
    /// </summary>
    public sealed class HardwireCodeGenerationContext
    {
        /// <summary>
        /// Gets the compile unit.
        /// </summary>
        internal CodeCompileUnit CompileUnit { get; private set; }

        private CodeStatementCollection _initStatements;
        private CodeTypeDeclaration _kickstarterClass;
        private readonly CodeNamespace _namespace;
        private readonly ICodeGenerationLogger _logger;
        private readonly ITimeProvider _timeProvider;

        private readonly Stack<string> _nestStack = new();

        /// <summary>
        /// Gets the target language emitting the hardwired sources.
        /// </summary>
        public HardwireCodeGenerationLanguage TargetLanguage { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether internal members are allowed in the generated code.
        /// </summary>
        public bool AllowInternals { get; internal set; }

        internal HardwireCodeGenerationContext(
            string namespaceName,
            string entryClassName,
            ICodeGenerationLogger logger,
            HardwireCodeGenerationLanguage language,
            ITimeProvider timeProvider = null
        )
        {
            if (string.IsNullOrWhiteSpace(namespaceName))
            {
                throw new ArgumentException(
                    "Namespace cannot be null or whitespace.",
                    nameof(namespaceName)
                );
            }

            if (string.IsNullOrWhiteSpace(entryClassName))
            {
                throw new ArgumentException(
                    "Entry class name cannot be null or whitespace.",
                    nameof(entryClassName)
                );
            }

            if (logger == null)
            {
                throw new ArgumentNullException(nameof(logger));
            }

            if (language == null)
            {
                throw new ArgumentNullException(nameof(language));
            }

            TargetLanguage = language;

            _logger = logger;
            _timeProvider = timeProvider ?? Script.DefaultOptions.TimeProvider;

            CompileUnit = new CodeCompileUnit();

            _namespace = new CodeNamespace(namespaceName);
            CompileUnit.Namespaces.Add(_namespace);

            Comment("----------------------------------------------------------");
            Comment(
                "Generated by NovaSharp.Hardwire v.{0}",
                Assembly.GetExecutingAssembly().GetName().Version
            );
            Comment("Compatible with NovaSharp v.{0} or equivalent", Script.VERSION);
            Comment("----------------------------------------------------------");

            string[] extraComments = language.GetInitialComment();

            if (extraComments != null)
            {
                foreach (string str in extraComments)
                {
                    Comment("{0}", str);
                }

                Comment("----------------------------------------------------------");
            }

            Comment(
                "Code generated on {0}",
                _timeProvider.GetUtcNow().UtcDateTime.ToString("O", CultureInfo.InvariantCulture)
            );
            Comment("----------------------------------------------------------");

            Comment("");
            Comment("");
            Comment("");

            GenerateKickstarter(entryClassName);
        }

        /// <summary>
        /// Generates the code from the specified dump table
        /// </summary>
        /// <param name="table">The table.</param>
        internal void GenerateCode(Table table)
        {
            if (table == null)
            {
                throw new ArgumentNullException(nameof(table));
            }

            DispatchTablePairs(
                table,
                _kickstarterClass.Members,
                (_, exp) =>
                    _initStatements.Add(
                        new CodeMethodInvokeExpression(
                            new CodeTypeReferenceExpression(typeof(UserData)),
                            "RegisterType",
                            exp
                        )
                    )
            );
        }

        /// <summary>
        /// Used by generators to dispatch a table of types
        /// </summary>
        /// <param name="table">The table.</param>
        /// <param name="members">The members.</param>
        /// <param name="action">The action to be performed, or null.</param>
        public void DispatchTablePairs(
            Table table,
            CodeTypeMemberCollection members,
            Action<string, CodeExpression> action = null
        )
        {
            if (table == null)
            {
                throw new ArgumentNullException(nameof(table));
            }

            if (members == null)
            {
                throw new ArgumentNullException(nameof(members));
            }

            foreach (TablePair pair in table.Pairs)
            {
                DynValue key = pair.Key;
                DynValue value = pair.Value;

                if (value.Type == DataType.Table && value.Table.Get("error").IsNotNil())
                {
                    value = value.Table.Get("error");
                }

                if (value.Type == DataType.Table)
                {
                    if (value.Table.Get("skip").IsNotNil())
                    {
                        continue;
                    }

                    if (!IsVisibilityAccepted(value.Table))
                    {
                        Warning(
                            "Type/Member '{0}' cannot be hardwired because its visibility is '{1}' (stack = {2}).",
                            key.String ?? "(null)",
                            value.Table.Get("visibility").String,
                            GetStackTrace()
                        );

                        continue;
                    }

                    CodeExpression[] exp = DispatchTable(key.String, value.Table, members);

                    if (action != null && exp != null)
                    {
                        foreach (CodeExpression e in exp)
                        {
                            action(key.String, e);
                        }
                    }
                }
                else
                {
                    if (value.Type == DataType.String)
                    {
                        Error(
                            "Type/Member '{0}' cannot be hardwired, error = '{1}' (stack = {2}).",
                            key.String ?? "(null)",
                            value.String ?? "(null)",
                            GetStackTrace()
                        );
                    }
                    else
                    {
                        Error(
                            "Type/Member '{0}' cannot be hardwired (stack = {1}).",
                            key.String ?? "(null)",
                            GetStackTrace()
                        );
                    }
                }
            }
        }

        /// <summary>
        /// Returns the current dispatcher stack trace for logging purposes.
        /// </summary>
        public string GetStackTrace()
        {
            return string.Join(" - ", _nestStack.ToArray());
        }

        /// <summary>
        /// Used by generators to dispatch a table of types
        /// </summary>
        /// <param name="table">The table.</param>
        /// <param name="members">The members.</param>
        /// <param name="action">The action to be performed, or null.</param>
        public void DispatchTablePairs(
            Table table,
            CodeTypeMemberCollection members,
            Action<CodeExpression> action
        )
        {
            if (action == null)
            {
                throw new ArgumentNullException(nameof(action));
            }
            DispatchTablePairs(table, members, (_, e) => action(e));
        }

        /// <summary>
        /// Used by generators to dispatch a single table
        /// </summary>
        /// <param name="key">The key.</param>
        /// <param name="table">The table.</param>
        /// <param name="members">The members.</param>
        /// <returns></returns>
        /// <exception cref="System.ArgumentException">table cannot be dispatched as it has no class or class of invalid type.</exception>
        public CodeExpression[] DispatchTable(
            string key,
            Table table,
            CodeTypeMemberCollection members
        )
        {
            if (table == null)
            {
                throw new ArgumentNullException(nameof(table));
            }

            if (members == null)
            {
                throw new ArgumentNullException(nameof(members));
            }

            DynValue d = table.Get("class");
            if (d.Type != DataType.String)
            {
                throw new ArgumentException(
                    "table cannot be dispatched as it has no class or class of invalid type."
                );
            }

            //m_NestStack.Push(string.Format("{0}[{1}]", key, d.String));

            _nestStack.Push((key ?? d.String) ?? "(null)");

            table.Set("$key", DynValue.NewString(key));

            IHardwireGenerator gen = HardwireGeneratorRegistry.GetGenerator(d.String);
            CodeExpression[] result = gen.Generate(table, this, members);

            _nestStack.Pop();

            return result;
        }

        /// <summary>
        /// Adds a comment to the source code head
        /// </summary>
        /// <param name="format">The format.</param>
        /// <param name="args">The arguments.</param>
        public void Comment(string format, params object[] args)
        {
            string str = FormatString(format, args);
            _namespace.Comments.Add(new CodeCommentStatement(str));
        }

        /// <summary>
        /// Reports a code generation error message
        /// </summary>
        /// <param name="format">The format.</param>
        /// <param name="args">The arguments.</param>
        public void Error(string format, params object[] args)
        {
            string str = FormatString(format, args);
            _namespace.Comments.Add(new CodeCommentStatement("ERROR : " + str));
            _logger.LogError(str);
        }

        /// <summary>
        /// Reports a code generation warning message
        /// </summary>
        /// <param name="format">The format.</param>
        /// <param name="args">The arguments.</param>
        public void Warning(string format, params object[] args)
        {
            string str = FormatString(format, args);
            _namespace.Comments.Add(new CodeCommentStatement("WARNING : " + str));
            _logger.LogWarning(str);
        }

        /// <summary>
        /// Reports a code generation warning message
        /// </summary>
        /// <param name="format">The format.</param>
        /// <param name="args">The arguments.</param>
        public void Minor(string format, params object[] args)
        {
            string str = FormatString(format, args);
            _namespace.Comments.Add(new CodeCommentStatement("Minor : " + str));
            _logger.LogMinor(str);
        }

        /// <summary>
        /// Determines whether a member with the specified visibility may be hardwired.
        /// </summary>
        public bool IsVisibilityAccepted(Table t)
        {
            if (t == null)
            {
                throw new ArgumentNullException(nameof(t));
            }
            DynValue dv = t.Get("visibility");

            if (dv.Type != DataType.String)
            {
                return true;
            }

            if (dv.String == "public")
            {
                return true;
            }

            if (dv.String == "internal" || dv.String == "protected-internal")
            {
                return AllowInternals;
            }

            return false;
        }

        private static string FormatString(string format, object[] args)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            if (args == null || args.Length == 0)
            {
                return format;
            }

            return string.Format(CultureInfo.InvariantCulture, format, args);
        }

        private void GenerateKickstarter(string className)
        {
            CodeTypeDeclaration cl = new(className)
            {
                TypeAttributes = TypeAttributes.Public | TypeAttributes.Abstract,
            };

            _namespace.Types.Add(cl);

            CodeConstructor ctor = new() { Attributes = MemberAttributes.Private };
            cl.Members.Add(ctor);

            CodeMemberMethod m = new()
            {
                Name = "Initialize",
                Attributes = MemberAttributes.Static | MemberAttributes.Public,
            };

            cl.Members.Add(m);

            this._initStatements = m.Statements;
            this._kickstarterClass = cl;
        }
    }
}
