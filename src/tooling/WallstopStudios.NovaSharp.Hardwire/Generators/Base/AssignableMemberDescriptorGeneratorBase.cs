namespace WallstopStudios.NovaSharp.Hardwire.Generators.Base
{
    using System;
    using System.CodeDom;
    using WallstopStudios.NovaSharp.Interpreter;
    using WallstopStudios.NovaSharp.Interpreter.DataTypes;
    using WallstopStudios.NovaSharp.Interpreter.Interop.BasicDescriptors;
    using WallstopStudios.NovaSharp.Interpreter.Interop.StandardDescriptors.HardwiredDescriptors;

    /// <summary>
    /// Base generator for descriptors that expose assignable members (properties/fields).
    /// </summary>
    internal abstract class AssignableMemberDescriptorGeneratorBase : IHardwireGenerator
    {
        /// <summary>
        /// Gets the fully qualified managed type generated by the derived class.
        /// </summary>
        public abstract string ManagedType { get; }

        protected abstract CodeExpression GetMemberAccessExpression(
            CodeExpression thisObj,
            string name
        );

        protected abstract string GetPrefix();

        /// <inheritdoc />
        /// <summary>
        /// Builds a nested descriptor type that wraps the described member and exposes read/write access.
        /// </summary>
        /// <param name="table">Dump table with member metadata.</param>
        /// <param name="generator">Code generation context for logging.</param>
        /// <param name="members">Collection receiving the generated type.</param>
        /// <returns>Expressions that instantiate the descriptor.</returns>
        public CodeExpression[] Generate(
            Table table,
            HardwireCodeGenerationContext generatorContext,
            CodeTypeMemberCollection members
        )
        {
            if (table == null)
            {
                throw new ArgumentNullException(nameof(table));
            }

            if (generatorContext == null)
            {
                throw new ArgumentNullException(nameof(generatorContext));
            }

            if (members == null)
            {
                throw new ArgumentNullException(nameof(members));
            }

            bool isStatic = table.Get("static").Boolean;
            string memberType = table.Get("type").String;
            string name = table.Get("name").String;
            string decltype = table.Get("decltype").String;
            bool declvtype = table.Get("declvtype").Boolean;
            bool canWrite = table.Get("write").Boolean;
            bool canRead = table.Get("read").Boolean;

            if (declvtype && canWrite)
            {
                generatorContext.Warning(
                    "Member '{0}.{1}::Set' will be a no-op, as it's a member of a value type.",
                    decltype,
                    name
                );
            }

            MemberDescriptorAccess access = 0;

            if (canWrite)
            {
                access = access | MemberDescriptorAccess.CanWrite;
            }

            if (canRead)
            {
                access = access | MemberDescriptorAccess.CanRead;
            }

            string className = GetPrefix() + "_" + Guid.NewGuid().ToString("N");

            CodeTypeDeclaration classCode = new(className)
            {
                TypeAttributes =
                    System.Reflection.TypeAttributes.NestedPrivate
                    | System.Reflection.TypeAttributes.Sealed,
            };

            classCode.BaseTypes.Add(typeof(HardwiredMemberDescriptor));

            // protected HardwiredMemberDescriptor(Type memberType, string name, bool isStatic, MemberDescriptorAccess access)

            CodeConstructor ctor = new() { Attributes = MemberAttributes.Assembly };
            ctor.BaseConstructorArgs.Add(new CodeTypeOfExpression(memberType));
            ctor.BaseConstructorArgs.Add(new CodePrimitiveExpression(name));
            ctor.BaseConstructorArgs.Add(new CodePrimitiveExpression(isStatic));
            ctor.BaseConstructorArgs.Add(
                new CodeCastExpression(
                    typeof(MemberDescriptorAccess),
                    new CodePrimitiveExpression((int)access)
                )
            );
            classCode.Members.Add(ctor);

            CodeExpression thisExp = isStatic
                ? (CodeExpression)(new CodeTypeReferenceExpression(decltype))
                : (CodeExpression)(
                    new CodeCastExpression(decltype, new CodeVariableReferenceExpression("obj"))
                );

            if (canRead)
            {
                CodeExpression memberExp = GetMemberAccessExpression(thisExp, name);
                //	protected virtual object GetValueCore(Script script, object obj)
                CodeMemberMethod m = new();
                classCode.Members.Add(m);
                m.Name = "GetValueCore";
                m.Attributes = MemberAttributes.Override | MemberAttributes.Family;
                m.ReturnType = new CodeTypeReference(typeof(object));
                m.Parameters.Add(new CodeParameterDeclarationExpression(typeof(Script), "script"));
                m.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "obj"));
                m.Statements.Add(new CodeMethodReturnStatement(memberExp));
            }

            if (canWrite)
            {
                //	protected virtual object GetValueCore(Script script, object obj)
                CodeMemberMethod m = new();
                classCode.Members.Add(m);
                m.Name = "SetValueCore";
                m.Attributes = MemberAttributes.Override | MemberAttributes.Family;
                m.Parameters.Add(new CodeParameterDeclarationExpression(typeof(Script), "script"));
                m.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "obj"));
                m.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "value"));

                CodeCastExpression valExp = new(
                    memberType,
                    new CodeVariableReferenceExpression("value")
                );

                if (isStatic)
                {
                    CodeExpression e = GetMemberAccessExpression(thisExp, name);
                    m.Statements.Add(new CodeAssignStatement(e, valExp));
                }
                else
                {
                    m.Statements.Add(
                        new CodeVariableDeclarationStatement(decltype, "tmp", thisExp)
                    );

                    CodeExpression memberExp = GetMemberAccessExpression(
                        new CodeVariableReferenceExpression("tmp"),
                        name
                    );

                    m.Statements.Add(new CodeAssignStatement(memberExp, valExp));
                }
            }

            members.Add(classCode);
            return new CodeExpression[] { new CodeObjectCreateExpression(className) };
        }
    }
}
