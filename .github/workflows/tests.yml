name: Tests

on:
  push:
    branches: [ master ]
  pull_request:

permissions:
  contents: read
  pull-requests: write

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Enforce NovaSharp branding
        run: ./scripts/branding/ensure-novasharp-branding.sh
        shell: bash
      - name: Verify namespace alignment
        run: python3 tools/NamespaceAudit/namespace_audit.py
      - name: Enforce naming conventions
        run: python3 tools/NamingAudit/naming_audit.py
      - name: Enforce script/doc README coverage
        run: ./scripts/ci/ensure-readme-updates.sh
        shell: bash
        env:
          NOVASHARP_BASE_REF: ${{ github.event_name == 'pull_request' && format('origin/{0}', github.base_ref) || 'HEAD^' }}

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Install Python tooling deps
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.tooling.txt
      - name: Markdown formatting + links
        env:
          NOVASHARP_BASE_REF: ${{ github.event_name == 'pull_request' && format('origin/{0}', github.base_ref) || 'HEAD^' }}
        run: ./scripts/ci/check-markdown.sh
        shell: bash

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'
      - name: CSharpier formatting gate
        run: ./scripts/ci/check-csharpier.sh
        shell: bash

  dotnet-tests:
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Enforce NovaSharp branding
        run: ./scripts/branding/ensure-novasharp-branding.sh
        shell: bash
      - name: Verify namespace alignment
        run: python3 tools/NamespaceAudit/namespace_audit.py
      - name: Enforce naming conventions
        run: python3 tools/NamingAudit/naming_audit.py

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'
      - name: Restore dependencies
        run: dotnet restore src/NovaSharp.sln
      - name: Restore tools
        run: dotnet tool restore
      - name: Build + test via helper script
        run: ./scripts/build/build.sh --skip-tool-restore
        shell: bash
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: NovaSharp-test-results
          path: artifacts/test-results
          if-no-files-found: error

  lint-autofix:
    needs: lint
    if: ${{ always() && github.event_name == 'pull_request' && needs.lint.result == 'failure' && github.event.pull_request.head.repo.fork == false }}
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Install Python tooling deps
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.tooling.txt
      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'
      - name: Apply repository formatters
        run: ./scripts/ci/apply-formatters.sh
        shell: bash
      - name: Detect auto-fix changes
        id: autofix_changes
        run: |
          if git status --porcelain | grep -q .; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Create auto-fix PR
        if: steps.autofix_changes.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: apply lint autofixes"
          branch: autofix/pr-${{ github.event.number }}-lint
          base: ${{ github.head_ref }}
          title: "Autofix lint issues for #${{ github.event.number }}"
          body: |
            This automated PR applies repository formatting fixes (CSharpier + markdownlint) detected in #${{ github.event.number }}.

            Merge this branch into `${{ github.head_ref }}` to adopt the fixes, or close it if you prefer to address the issues manually.
          labels: autofix, automation
          draft: true
      - name: No auto-fix changes detected
        if: steps.autofix_changes.outputs.changed != 'true'
        run: echo "Lint failures could not be auto-fixed (likely link issues)."

  code-coverage:
    runs-on: ubuntu-latest
    needs: dotnet-tests
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Enforce NovaSharp branding
        run: ./scripts/branding/ensure-novasharp-branding.sh
        shell: bash
      - name: Verify namespace alignment
        run: python3 tools/NamespaceAudit/namespace_audit.py

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'
      - name: Restore dependencies
        run: dotnet restore src/NovaSharp.sln
      - name: Restore tools
        run: dotnet tool restore
      - name: Generate coverage
        shell: pwsh
        env:
          COVERAGE_GATING_TARGET_LINE: "95"
          COVERAGE_GATING_TARGET_BRANCH: "95"
          COVERAGE_GATING_TARGET_METHOD: "95"
          COVERAGE_GATING_MODE: monitor
        run: ./scripts/coverage/coverage.ps1
      - name: Publish coverage summary
        if: always()
        run: |
          if [ -f artifacts/coverage/SummaryGithub.md ]; then
            {
              echo "## Code Coverage"
              echo
              cat artifacts/coverage/SummaryGithub.md
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Coverage summary not found." >> "$GITHUB_STEP_SUMMARY"
          fi
        shell: bash
      - name: Evaluate coverage threshold
        if: always()
        uses: actions/github-script@v8
        env:
          COVERAGE_THRESHOLD_LINE: "95"
          COVERAGE_THRESHOLD_BRANCH: "95"
          COVERAGE_THRESHOLD_METHOD: "95"
          COVERAGE_GATING_MODE: monitor
        with:
          script: |
            const fs = require('fs');
            const path = 'artifacts/coverage/Summary.json';
            if (!fs.existsSync(path)) {
              core.setFailed(`Coverage summary not available at ${path}`);
              return;
            }

            const raw = JSON.parse(fs.readFileSync(path, 'utf8'));
            const summary = raw.summary ?? {};
            const line = Number(summary.linecoverage);
            const branch = Number(summary.branchcoverage);
            const method = Number(summary.methodcoverage);
            const lineThreshold = Number(process.env.COVERAGE_THRESHOLD_LINE ?? '95');
            const branchThreshold = Number(process.env.COVERAGE_THRESHOLD_BRANCH ?? '95');
            const methodThreshold = Number(process.env.COVERAGE_THRESHOLD_METHOD ?? '95');
            let mode = (process.env.COVERAGE_GATING_MODE ?? 'monitor').trim().toLowerCase();

            if (!Number.isFinite(line)) {
              core.setFailed('Line coverage percentage missing from Summary.json.');
              return;
            }

            if (!['monitor', 'enforce', 'disabled'].includes(mode)) {
              core.warning(`Unknown COVERAGE_GATING_MODE "${mode}" supplied; defaulting to monitor.`);
              mode = 'monitor';
            }

            const summaryPath = process.env.GITHUB_STEP_SUMMARY;
            const fmt = (value) => Number.isFinite(value) ? `${value.toFixed(2)}%` : 'n/a';
            const summaryLines = [
              '### Coverage Gate',
              '',
              `- Mode: ${mode}`,
              `- Line: ${fmt(line)} (threshold ${lineThreshold.toFixed(2)}%)`,
              `- Branch: ${fmt(branch)} (threshold ${branchThreshold.toFixed(2)}%)`,
              `- Method: ${fmt(method)} (threshold ${methodThreshold.toFixed(2)}%)`,
              ''
            ];

            if (summaryPath) {
              fs.appendFileSync(summaryPath, `${summaryLines.join('\n')}\n`);
            }

            if (mode === 'disabled') {
              core.notice('Coverage gating disabled via COVERAGE_GATING_MODE.');
              return;
            }

            const violations = [];
            const compare = (value, threshold, label) => {
              if (!Number.isFinite(value)) {
                if (threshold > 0) {
                  violations.push(`${label} coverage unavailable (threshold ${threshold.toFixed(2)}%)`);
                }
                return;
              }

              const delta = value - threshold;
              if (threshold > 0 && delta < 0) {
                violations.push(`${label} coverage ${value.toFixed(2)}% is ${Math.abs(delta).toFixed(2)}% below the ${threshold.toFixed(2)}% threshold`);
              }
            };

            compare(line, lineThreshold, 'Line');
            compare(branch, branchThreshold, 'Branch');
            compare(method, methodThreshold, 'Method');

            if (violations.length > 0) {
              const message = violations.join('; ');
              if (mode === 'enforce') {
                core.setFailed(`${message}. Gating mode set to "enforce"; failing job.`);
              } else {
                core.warning(`${message}. Monitoring mode active; job will continue.`);
              }
              return;
            }

            const success = `Line/Branch/Method coverage meet or exceed the configured thresholds (mode: ${mode}).`;
            if (mode === 'enforce') {
              core.notice(success);
            } else {
              core.info(success);
            }
      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = 'artifacts/coverage/Summary.json';
            const marker = '<!-- coverage-report -->';
            if (!fs.existsSync(path)) {
              core.warning(`Coverage summary not available at ${path}`);
              return;
            }
            const data = JSON.parse(fs.readFileSync(path, 'utf8'));
            const summary = data.summary ?? {};
            const fmt = (value) => value === undefined || value === null ? 'n/a' : `${value.toFixed(2)}%`;
            const line = summary.linecoverage ?? 0;
            const branch = summary.branchcoverage ?? 0;
            const method = summary.methodcoverage ?? 0;
            const coveredLines = summary.coveredlines ?? 0;
            const coverableLines = summary.coverablelines ?? 0;
            const coveredBranches = summary.coveredbranches ?? 0;
            const totalBranches = summary.totalbranches ?? 0;
            const coveredMethods = summary.coveredmethods ?? 0;
            const totalMethods = summary.totalmethods ?? 0;
            const body = `${marker}
            ## Code Coverage
            | Metric | Coverage |
            | --- | --- |
            | Line | ${fmt(line)} (${coveredLines}/${coverableLines}) |
            | Branch | ${fmt(branch)} (${coveredBranches}/${totalBranches}) |
            | Method | ${fmt(method)} (${coveredMethods}/${totalMethods}) |

            _Generated by coverage.ps1_`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const previous = comments.find((comment) =>
              comment.user?.type === 'Bot' && comment.body?.includes(marker)
            );

            if (previous) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: previous.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }
      - name: Archive HTML coverage
        if: always()
        run: |
          tar -czf coverage-html.tgz -C docs/coverage latest
        shell: bash
      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: coverage-artifacts
          path: |
            artifacts/coverage
            coverage-html.tgz
          if-no-files-found: error
