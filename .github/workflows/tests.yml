name: Tests

on:
  push:
    branches: [ main ]
  pull_request:

permissions:
  contents: read
  pull-requests: write

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Install Python tooling deps
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.tooling.txt
      - name: Enforce NovaSharp branding
        run: ./scripts/branding/ensure-novasharp-branding.sh
        shell: bash
      - name: Verify namespace alignment
        run: python3 tools/NamespaceAudit/namespace_audit.py
      - name: Enforce naming conventions
        run: python3 tools/NamingAudit/naming_audit.py --namespace-prefix WallstopStudios.NovaSharp --namespace-prefix NovaSharp
      - name: Verify naming audit log
        run: python3 tools/NamingAudit/naming_audit.py --namespace-prefix WallstopStudios.NovaSharp --namespace-prefix NovaSharp --verify-log docs/audits/naming_audit.log
      - name: Enforce spelling conventions
        run: python3 tools/SpellingAudit/spelling_audit.py
      - name: Verify spelling audit log
        run: python3 tools/SpellingAudit/spelling_audit.py --verify-log docs/audits/spelling_audit.log
      - name: Generate documentation audit log
        run: python3 tools/DocumentationAudit/documentation_audit.py --write-log docs/audits/documentation_audit.log
      - name: Verify documentation audit log
        run: |
          if ! git diff --quiet -- docs/audits/documentation_audit.log; then
            echo "::error file=docs/audits/documentation_audit.log::docs/audits/documentation_audit.log is out of date. Run 'python tools/DocumentationAudit/documentation_audit.py --write-log docs/audits/documentation_audit.log' and commit the result."
            git --no-pager diff -- docs/audits/documentation_audit.log
            exit 1
          fi
      - name: Determine documentation diff base
        id: doc_diff_base
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          BASE_REF: ${{ github.base_ref }}
          BEFORE_SHA: ${{ github.event.before }}
        run: |
          if [[ "$EVENT_NAME" == "pull_request" ]]; then
            git fetch origin "$BASE_REF" --depth=1
            merge_base="$(git merge-base HEAD "origin/$BASE_REF")"
          else
            merge_base="${BEFORE_SHA:-$(git rev-parse HEAD^)}"
          fi
          echo "merge_base=$merge_base" >> "$GITHUB_OUTPUT"
      - name: Enforce script/doc README coverage
        run: ./scripts/ci/ensure-readme-updates.sh
        shell: bash
        env:
          NOVASHARP_BASE_REF: ${{ steps.doc_diff_base.outputs.merge_base }}
      - name: Verify fixture catalog is current
        shell: pwsh
        run: ./scripts/ci/check-fixture-catalog.ps1

      - name: Markdown formatting + links
        env:
          NOVASHARP_BASE_REF: ${{ steps.doc_diff_base.outputs.merge_base }}
        run: ./scripts/ci/check-markdown.sh
        shell: bash

      - name: Setup .NET (formatting gate)
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'
      - name: Restore dotnet tools
        run: dotnet tool restore
      - name: CSharpier formatting gate
        run: ./scripts/ci/check-csharpier.sh
        shell: bash

      - name: Enforce PlatformAutoDetector scope usage
        run: ./scripts/ci/check-platform-testhooks.sh
        shell: bash

      - name: Enforce ConsoleCapture coordinator usage
        run: ./scripts/ci/check-console-capture-semaphore.sh
        shell: bash

      - name: Enforce shell script executable permissions
        run: ./scripts/ci/check-shell-executable.sh
        shell: bash

      - name: Enforce Python invocation pattern in shell scripts
        run: ./scripts/ci/check-shell-python-invocation.sh
        shell: bash

  dotnet-tests:
    needs: lint
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      # Lint checks already passed in the 'lint' job (this job has needs: lint).
      # Skip redundant branding/namespace/naming/spelling/documentation/fixture-catalog steps.
      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'
          cache: true
          cache-dependency-path: 'src/**/packages.lock.json'
      - name: Restore dependencies
        run: dotnet restore src/NovaSharp.sln --locked-mode
      - name: Restore tools
        run: dotnet tool restore
      - name: Build + test via helper script (Linux/macOS)
        if: runner.os != 'Windows'
        run: ./scripts/build/build.sh --skip-tool-restore --skip-restore
        shell: bash
      - name: Build + test via helper script (Windows)
        if: runner.os == 'Windows'
        run: ./scripts/build/build.ps1 -SkipToolRestore -SkipRestore
        shell: pwsh
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: NovaSharp-test-results-${{ matrix.os }}
          path: artifacts/test-results
          if-no-files-found: error

  lint-autofix:
    needs: lint
    if: ${{ always() && github.event_name == 'pull_request' && needs.lint.result == 'failure' && github.event.pull_request.head.repo.fork == false }}
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Install Python tooling deps
        run: |
          python -m pip install --upgrade pip
          python -m pip install -r requirements.tooling.txt
      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'
          # Note: cache not needed here - this job only runs formatters, not restore
      - name: Apply repository formatters
        run: ./scripts/ci/apply-formatters.sh
        shell: bash
      - name: Detect auto-fix changes
        id: autofix_changes
        run: |
          if git status --porcelain | grep -q .; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Create auto-fix PR
        if: steps.autofix_changes.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: apply lint autofixes"
          branch: autofix/pr-${{ github.event.number }}-lint
          base: ${{ github.head_ref }}
          title: "Autofix lint issues for #${{ github.event.number }}"
          body: |
            This automated PR applies repository formatting fixes (CSharpier + markdownlint) detected in #${{ github.event.number }}.

            Merge this branch into `${{ github.head_ref }}` to adopt the fixes, or close it if you prefer to address the issues manually.
          labels: autofix, automation
          draft: true
      - name: No auto-fix changes detected
        if: steps.autofix_changes.outputs.changed != 'true'
        run: echo "Lint failures could not be auto-fixed (likely link issues)."

  code-coverage:
    runs-on: ubuntu-latest
    needs: dotnet-tests
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      # Lint checks already passed in the 'lint' job (via dotnet-tests dependency).
      # Skip redundant branding/namespace checks.
      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'
      - name: Restore dependencies
        run: dotnet restore src/NovaSharp.sln --locked-mode
      - name: Restore tools
        run: dotnet tool restore
      - name: Generate coverage
        shell: pwsh
        env:
          COVERAGE_GATING_TARGET_LINE: "80"
          COVERAGE_GATING_TARGET_BRANCH: "80"
          COVERAGE_GATING_TARGET_METHOD: "80"
          COVERAGE_GATING_MODE: enforce
        run: ./scripts/coverage/coverage.ps1 -SkipRestore
      - name: Publish coverage summary
        if: always()
        run: |
          if [ -f artifacts/coverage/SummaryGithub.md ]; then
            {
              echo "## Code Coverage"
              echo
              cat artifacts/coverage/SummaryGithub.md
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "Coverage summary not found." >> "$GITHUB_STEP_SUMMARY"
          fi
        shell: bash
      - name: Evaluate coverage threshold
        if: always()
        uses: actions/github-script@v8
        env:
          COVERAGE_THRESHOLD_LINE: "80"
          COVERAGE_THRESHOLD_BRANCH: "80"
          COVERAGE_THRESHOLD_METHOD: "80"
          COVERAGE_GATING_MODE: enforce
        with:
          script: |
            const fs = require('fs');
            const path = 'artifacts/coverage/Summary.json';
            if (!fs.existsSync(path)) {
              core.setFailed(`Coverage summary not available at ${path}`);
              return;
            }

            const raw = JSON.parse(fs.readFileSync(path, 'utf8'));
            const summary = raw.summary ?? {};
            const line = Number(summary.linecoverage);
            const branch = Number(summary.branchcoverage);
            const method = Number(summary.methodcoverage);
            const lineThreshold = Number(process.env.COVERAGE_THRESHOLD_LINE ?? '95');
            const branchThreshold = Number(process.env.COVERAGE_THRESHOLD_BRANCH ?? '95');
            const methodThreshold = Number(process.env.COVERAGE_THRESHOLD_METHOD ?? '95');
            let mode = (process.env.COVERAGE_GATING_MODE ?? 'monitor').trim().toLowerCase();

            if (!Number.isFinite(line)) {
              core.setFailed('Line coverage percentage missing from Summary.json.');
              return;
            }

            if (!['monitor', 'enforce', 'disabled'].includes(mode)) {
              core.warning(`Unknown COVERAGE_GATING_MODE "${mode}" supplied; defaulting to monitor.`);
              mode = 'monitor';
            }

            const summaryPath = process.env.GITHUB_STEP_SUMMARY;
            const fmt = (value) => Number.isFinite(value) ? `${value.toFixed(2)}%` : 'n/a';
            const summaryLines = [
              '### Coverage Gate',
              '',
              `- Mode: ${mode}`,
              `- Line: ${fmt(line)} (threshold ${lineThreshold.toFixed(2)}%)`,
              `- Branch: ${fmt(branch)} (threshold ${branchThreshold.toFixed(2)}%)`,
              `- Method: ${fmt(method)} (threshold ${methodThreshold.toFixed(2)}%)`,
              ''
            ];

            if (summaryPath) {
              fs.appendFileSync(summaryPath, `${summaryLines.join('\n')}\n`);
            }

            if (mode === 'disabled') {
              core.notice('Coverage gating disabled via COVERAGE_GATING_MODE.');
              return;
            }

            const violations = [];
            const compare = (value, threshold, label) => {
              if (!Number.isFinite(value)) {
                if (threshold > 0) {
                  violations.push(`${label} coverage unavailable (threshold ${threshold.toFixed(2)}%)`);
                }
                return;
              }

              const delta = value - threshold;
              if (threshold > 0 && delta < 0) {
                violations.push(`${label} coverage ${value.toFixed(2)}% is ${Math.abs(delta).toFixed(2)}% below the ${threshold.toFixed(2)}% threshold`);
              }
            };

            compare(line, lineThreshold, 'Line');
            compare(branch, branchThreshold, 'Branch');
            compare(method, methodThreshold, 'Method');

            if (violations.length > 0) {
              const message = violations.join('; ');
              if (mode === 'enforce') {
                core.setFailed(`${message}. Gating mode set to "enforce"; failing job.`);
              } else {
                core.warning(`${message}. Monitoring mode active; job will continue.`);
              }
              return;
            }

            const success = `Line/Branch/Method coverage meet or exceed the configured thresholds (mode: ${mode}).`;
            if (mode === 'enforce') {
              core.notice(success);
            } else {
              core.info(success);
            }
      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = 'artifacts/coverage/Summary.json';
            const marker = '<!-- coverage-report -->';
            if (!fs.existsSync(path)) {
              core.warning(`Coverage summary not available at ${path}`);
              return;
            }
            const data = JSON.parse(fs.readFileSync(path, 'utf8'));
            const summary = data.summary ?? {};
            const fmt = (value) => value === undefined || value === null ? 'n/a' : `${value.toFixed(2)}%`;
            const line = summary.linecoverage ?? 0;
            const branch = summary.branchcoverage ?? 0;
            const method = summary.methodcoverage ?? 0;
            const coveredLines = summary.coveredlines ?? 0;
            const coverableLines = summary.coverablelines ?? 0;
            const coveredBranches = summary.coveredbranches ?? 0;
            const totalBranches = summary.totalbranches ?? 0;
            const coveredMethods = summary.coveredmethods ?? 0;
            const totalMethods = summary.totalmethods ?? 0;
            const body = `${marker}
            ## Code Coverage
            | Metric | Coverage |
            | --- | --- |
            | Line | ${fmt(line)} (${coveredLines}/${coverableLines}) |
            | Branch | ${fmt(branch)} (${coveredBranches}/${totalBranches}) |
            | Method | ${fmt(method)} (${coveredMethods}/${totalMethods}) |

            _Generated by coverage.ps1_`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const previous = comments.find((comment) =>
              comment.user?.type === 'Bot' && comment.body?.includes(marker)
            );

            if (previous) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: previous.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }
      - name: Archive HTML coverage
        if: always()
        run: |
          tar -czf coverage-html.tgz -C docs/coverage latest
        shell: bash
      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: coverage-artifacts
          path: |
            artifacts/coverage
            coverage-html.tgz
          if-no-files-found: error

  lua-comparison:
    needs: dotnet-tests
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        lua-version: ['5.1', '5.2', '5.3', '5.4', '5.5']
      fail-fast: false
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      # ========== Linux Lua Installation ==========
      - name: Install Lua ${{ matrix.lua-version }} (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          if apt-cache show "lua${{ matrix.lua-version }}" > /dev/null 2>&1; then
            sudo apt-get install -y lua${{ matrix.lua-version }}
          else
            echo "lua${{ matrix.lua-version }} not in apt, building from source..."
            sudo apt-get install -y build-essential libreadline-dev
            LUA_VERSION="${{ matrix.lua-version }}"
            # Determine the full version (latest patch release)
            case "$LUA_VERSION" in
              5.1) FULL_VERSION="5.1.5" ;;
              5.2) FULL_VERSION="5.2.4" ;;
              5.3) FULL_VERSION="5.3.6" ;;
              5.4) FULL_VERSION="5.4.7" ;;
              5.5) FULL_VERSION="5.5.0" ;;
              *) echo "Unknown version $LUA_VERSION"; exit 1 ;;
            esac
            curl -fsSL "https://www.lua.org/ftp/lua-${FULL_VERSION}.tar.gz" | tar xz
            cd "lua-${FULL_VERSION}"
            make linux
            sudo make install INSTALL_TOP=/usr/local
            sudo ln -sf /usr/local/bin/lua /usr/local/bin/lua${LUA_VERSION}
            echo "/usr/local/bin" >> $GITHUB_PATH
          fi
        shell: bash

      # ========== macOS Lua Installation ==========
      - name: Install Lua ${{ matrix.lua-version }} (macOS)
        if: runner.os == 'macOS'
        run: |
          LUA_VERSION="${{ matrix.lua-version }}"
          
          # Check if exact version formula exists in Homebrew
          # Homebrew has lua (latest), lua@5.4, lua@5.3, etc.
          if [[ "$LUA_VERSION" == "5.4" ]]; then
            brew install lua
            # lua 5.4 is the main formula
            LUA_CMD="lua"
          elif brew search --formula "lua@${LUA_VERSION}" 2>/dev/null | grep -q "^lua@${LUA_VERSION}$"; then
            brew install "lua@${LUA_VERSION}"
            # Homebrew versioned formulas put binaries in opt
            echo "$(brew --prefix lua@${LUA_VERSION})/bin" >> $GITHUB_PATH
            LUA_CMD="lua${LUA_VERSION}"
          else
            echo "lua@${LUA_VERSION} not in Homebrew, building from source..."
            # Build Lua from source
            case "$LUA_VERSION" in
              5.1) FULL_VERSION="5.1.5" ;;
              5.2) FULL_VERSION="5.2.4" ;;
              5.3) FULL_VERSION="5.3.6" ;;
              5.4) FULL_VERSION="5.4.7" ;;
              5.5) FULL_VERSION="5.5.0" ;;
              *) echo "Unknown version $LUA_VERSION"; exit 1 ;;
            esac
            curl -fsSL "https://www.lua.org/ftp/lua-${FULL_VERSION}.tar.gz" | tar xz
            cd "lua-${FULL_VERSION}"
            make macosx
            sudo make install INSTALL_TOP=/usr/local
            sudo ln -sf /usr/local/bin/lua /usr/local/bin/lua${LUA_VERSION}
            echo "/usr/local/bin" >> $GITHUB_PATH
          fi
        shell: bash

      # ========== Windows Lua Installation ==========
      # Build from official lua.org source using MSVC (most reliable approach).
      # SourceForge downloads are unreliable and often return HTML instead of zip files.
      # We need to set up the Visual Studio Developer environment first to make cl.exe available.
      - name: Setup MSVC Developer Command Prompt (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      - name: Install Lua ${{ matrix.lua-version }} (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $LuaVersion = "${{ matrix.lua-version }}"
          
          # Map version to full patch version
          $VersionMap = @{
            "5.1" = "5.1.5"
            "5.2" = "5.2.4"
            "5.3" = "5.3.6"
            "5.4" = "5.4.7"
            "5.5" = "5.5.0"
          }
          
          if (-not $VersionMap.ContainsKey($LuaVersion)) {
            Write-Error "Unknown Lua version: $LuaVersion"
            exit 1
          }
          
          $FullVersion = $VersionMap[$LuaVersion]
          $LuaDir = "C:\Lua\$LuaVersion"
          New-Item -ItemType Directory -Force -Path $LuaDir | Out-Null
          
          # Download official Lua source from lua.org (always works, no SourceForge issues)
          $LuaSrcUrl = "https://www.lua.org/ftp/lua-$FullVersion.tar.gz"
          Write-Host "Downloading Lua $FullVersion source from $LuaSrcUrl..."
          Invoke-WebRequest -Uri $LuaSrcUrl -OutFile "$env:TEMP\lua.tar.gz" -UseBasicParsing
          
          # Extract using tar (available on Windows 10+)
          Push-Location $env:TEMP
          tar -xzf lua.tar.gz
          Pop-Location
          
          # Build with MSVC (cl.exe is now available via msvc-dev-cmd action)
          $SrcDir = "$env:TEMP\lua-$FullVersion\src"
          Write-Host "Building Lua from source in $SrcDir..."
          Push-Location $SrcDir
          
          # Define source files (common to all versions)
          $CoreFiles = @(
            "lapi.c", "lcode.c", "ldebug.c", "ldo.c", "ldump.c", 
            "lfunc.c", "lgc.c", "llex.c", "lmem.c", "lobject.c", "lopcodes.c",
            "lparser.c", "lstate.c", "lstring.c", "ltable.c", "ltm.c", 
            "lundump.c", "lvm.c", "lzio.c"
          )
          # lctype.c added in 5.2+
          $LibFiles = @(
            "lauxlib.c", "lbaselib.c", "ldblib.c", "liolib.c",
            "lmathlib.c", "loadlib.c", "loslib.c", "lstrlib.c", "ltablib.c", "linit.c"
          )
          # Version-specific files
          # lcorolib.c (coroutine library as separate file): 5.2+
          # lutf8lib.c (utf8 library): 5.3+
          # lctype.c: 5.2+
          
          # Filter to existing files (handles version differences automatically)
          $AllCFiles = ($CoreFiles + $LibFiles + @("lctype.c", "lcorolib.c", "lutf8lib.c")) | Where-Object { Test-Path $_ }
          
          Write-Host "Compiling $($AllCFiles.Count) source files..."
          
          # Compile all library .c files to .obj
          foreach ($f in $AllCFiles) {
            $output = & cl.exe /c /O2 /MD /W3 /nologo $f 2>&1
            if ($LASTEXITCODE -ne 0) {
              Write-Host "Failed to compile ${f}:"
              Write-Host $output
              exit 1
            }
          }
          
          # Compile lua.c for the interpreter
          $output = & cl.exe /c /O2 /MD /W3 /nologo lua.c 2>&1
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Failed to compile lua.c:"
            Write-Host $output
            exit 1
          }
          
          # Link the interpreter (all .obj files including lua.obj)
          $ObjFiles = (Get-ChildItem -Filter "*.obj").Name
          Write-Host "Linking $($ObjFiles.Count) object files..."
          $output = & cl.exe /nologo /Fe:lua.exe $ObjFiles 2>&1
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Failed to link:"
            Write-Host $output
            exit 1
          }
          
          if (Test-Path "lua.exe") {
            Copy-Item "lua.exe" $LuaDir -Force
            Write-Host "Successfully built lua.exe"
          }
          else {
            Write-Error "lua.exe not found after build"
            exit 1
          }
          Pop-Location
          
          # Create versioned alias (lua5.4.exe -> lua.exe)
          $LuaExe = Join-Path $LuaDir "lua.exe"
          $LuaVersionedExe = Join-Path $LuaDir "lua$LuaVersion.exe"
          Copy-Item $LuaExe $LuaVersionedExe -Force
          
          # Add to PATH for this job
          Write-Host "Adding $LuaDir to PATH"
          "$LuaDir" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
          
          # Verify installation
          $env:PATH = "$LuaDir;$env:PATH"
          & "$LuaDir\lua.exe" -v

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore src/NovaSharp.sln --locked-mode

      - name: Build NovaSharp CLI
        run: dotnet build src/tooling/WallstopStudios.NovaSharp.Cli/WallstopStudios.NovaSharp.Cli.csproj -c Release --no-restore

      - name: Verify Lua fixtures exist (Unix)
        if: runner.os != 'Windows'
        run: |
          if [ ! -d "src/tests/WallstopStudios.NovaSharp.Interpreter.Tests/LuaFixtures" ]; then
            echo "Error: Lua fixtures not found. Run 'python3 tools/LuaCorpusExtractor/lua_corpus_extractor_v2.py' and commit the results."
            exit 1
          fi
          fixture_count=$(find src/tests/WallstopStudios.NovaSharp.Interpreter.Tests/LuaFixtures -name "*.lua" | wc -l)
          echo "Found $fixture_count Lua fixture files"
        shell: bash

      - name: Verify Lua fixtures exist (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $FixturesDir = "src/tests/WallstopStudios.NovaSharp.Interpreter.Tests/LuaFixtures"
          if (-not (Test-Path $FixturesDir)) {
            Write-Error "Lua fixtures not found. Run 'python3 tools/LuaCorpusExtractor/lua_corpus_extractor_v2.py' and commit the results."
            exit 1
          }
          $FixtureCount = (Get-ChildItem -Path $FixturesDir -Recurse -Filter "*.lua").Count
          Write-Host "Found $FixtureCount Lua fixture files"

      - name: Determine Lua command
        id: lua-cmd
        shell: bash
        run: |
          LUA_VERSION="${{ matrix.lua-version }}"
          
          # Try versioned command first, then unversioned
          if command -v "lua${LUA_VERSION}" &> /dev/null; then
            LUA_CMD="lua${LUA_VERSION}"
          elif command -v "lua$LUA_VERSION" &> /dev/null; then
            LUA_CMD="lua$LUA_VERSION"
          elif command -v lua &> /dev/null; then
            LUA_CMD="lua"
          else
            echo "Warning: Lua command not found in PATH"
            LUA_CMD="lua"
          fi
          
          echo "lua_cmd=$LUA_CMD" >> "$GITHUB_OUTPUT"
          echo "Using Lua command: $LUA_CMD"
          
          # Verify the command works
          $LUA_CMD -v || echo "Lua version check failed"

      - name: Run fixtures against Lua ${{ matrix.lua-version }} and NovaSharp (parallel)
        env:
          DOTNET_ROLL_FORWARD: Major
        run: |
          python3 scripts/tests/run-lua-fixtures-parallel.py \
            --lua-version ${{ matrix.lua-version }} \
            --lua-cmd "${{ steps.lua-cmd.outputs.lua_cmd }}" \
            --output-dir artifacts/lua-comparison-results \
            -v
        shell: bash

      - name: Compare outputs
        id: compare
        run: |
          python3 scripts/tests/compare-lua-outputs.py \
            --results-dir artifacts/lua-comparison-results \
            --corpus-dir src/tests/WallstopStudios.NovaSharp.Interpreter.Tests/LuaFixtures \
            --lua-version ${{ matrix.lua-version }} \
            --output-file artifacts/lua-comparison-results/comparison-${{ matrix.lua-version }}.json \
            --enforce
        shell: bash

      - name: Publish comparison summary
        if: always()
        run: |
          comparison_file="artifacts/lua-comparison-results/comparison-${{ matrix.lua-version }}.json"
          if [ -f "$comparison_file" ]; then
            python3 -c "
          import json
          with open('$comparison_file') as f:
              data = json.load(f)
          summary = data.get('summary', {})
          match_rate = data.get('match_rate')
          print('## Lua ${{ matrix.lua-version }} on ${{ matrix.os }} Specification Comparison')
          print()
          print('| Metric | Count |')
          print('| --- | --- |')
          print(f\"| Match | {summary.get('match', 0)} |\")
          print(f\"| Mismatch | {summary.get('mismatch', 0)} |\")
          print(f\"| Both Error | {summary.get('both_error', 0)} |\")
          print(f\"| Skipped | {summary.get('skipped', 0)} |\")
          print()
          if match_rate is not None:
              print(f'**Match Rate**: {match_rate:.1f}%')
          " >> "\$GITHUB_STEP_SUMMARY"
          else
            echo "Comparison results for Lua ${{ matrix.lua-version }} on ${{ matrix.os }} not found." >> "\$GITHUB_STEP_SUMMARY"
          fi
        shell: bash

      - name: Upload Lua ${{ matrix.lua-version }} comparison results
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: lua-comparison-${{ matrix.lua-version }}-${{ matrix.os }}
          path: artifacts/lua-comparison-results
          if-no-files-found: warn
